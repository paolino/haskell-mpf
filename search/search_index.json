{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Cardano MPFS Offchain","text":"<p>Haskell offchain companion to cardano-mpfs-onchain \u2014 indexing, transaction building, and submission for Cardano Merkle Patricia Forestry.</p>"},{"location":"#packages","title":"Packages","text":"Package Description <code>merkle-patricia-forestry</code> 16-ary hex Patricia trie with Blake2b-256, compatible with the Aiken on-chain implementation <code>cardano-mpfs-offchain</code> Off-chain service layer: N2C node client, UTxO provider, transaction balancing, submission, and skeleton indexer"},{"location":"#documentation","title":"Documentation","text":"<ul> <li>Architecture Overview \u2014 system diagram, phases, design principles</li> <li>Data Sources \u2014 N2C connection, mini-protocols, data flow</li> <li>Singletons \u2014 record-of-functions interfaces</li> <li>Testing \u2014 unit tests, E2E tests with cardano-node subprocess</li> </ul>"},{"location":"PHASE4-DESIGN/","title":"Phase 4 \u2014 Indexer + Persistence","text":""},{"location":"PHASE4-DESIGN/#goal","title":"Goal","text":"<p>Replace in-memory state (Mock.State, PureManager, Skeleton Indexer) with persistent, crash-safe storage backed by a single RocksDB instance shared with cardano-utxo-csmt. Every block is processed in one atomic WriteBatch covering UTxO index, cage state, and trie mutations.</p>"},{"location":"PHASE4-DESIGN/#design-principle-one-writebatch-per-block","title":"Design principle: one WriteBatch per block","text":"<p>The central invariant is atomicity at the block boundary. When a block arrives via ChainSync:</p> <ol> <li>Extract UTxO changes (cardano-utxo-csmt)</li> <li>Detect cage transactions (mpfs-offchain)</li> <li>Apply trie mutations (merkle-patricia-forestry)</li> <li>Commit all of the above in a single RocksDB WriteBatch</li> </ol> <p>If the process crashes at any point before the WriteBatch commits, no partial state is visible on recovery. If it crashes after the commit, all state is consistent.</p> <p>This is possible because <code>rocksdb-kv-transactions</code> was designed for exactly this: composable, multi-column-family atomic transactions over a shared RocksDB instance.</p>"},{"location":"PHASE4-DESIGN/#architecture","title":"Architecture","text":"<pre><code>Block (via N2C ChainSync)\n  \u2502\n  \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Single RocksDB Transaction (WriteBatch)         \u2502\n\u2502                                                  \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n\u2502  \u2502 UTxO CFs    \u2502  \u2502 Cage CFs \u2502  \u2502 Trie CFs   \u2502  \u2502\n\u2502  \u2502 kv          \u2502  \u2502 tokens   \u2502  \u2502 trie-nodes \u2502  \u2502\n\u2502  \u2502 csmt        \u2502  \u2502 requests \u2502  \u2502 trie-kv    \u2502  \u2502\n\u2502  \u2502 rollbacks   \u2502  \u2502 cage-cfg \u2502  \u2502            \u2502  \u2502\n\u2502  \u2502 config      \u2502  \u2502          \u2502  \u2502            \u2502  \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n\u2502                                                  \u2502\n\u2502  applyOps \u2192 single WriteBatch \u2192 atomic commit    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"PHASE4-DESIGN/#column-families","title":"Column families","text":"Column family Owner Key Value <code>kv</code> cardano-utxo-csmt CBOR TxIn CBOR TxOut <code>csmt</code> cardano-utxo-csmt CSMT Key CSMT Indirect hash <code>rollbacks</code> cardano-utxo-csmt WithOrigin SlotNo RollbackPoint <code>config</code> cardano-utxo-csmt ConfigKey ByteString <code>tokens</code> mpfs-offchain TokenId TokenState <code>requests</code> mpfs-offchain TxIn Request <code>cage-cfg</code> mpfs-offchain () CageCheckpoint <code>trie-nodes</code> merkle-patricia-forestry HexKey HexIndirect hash <code>trie-kv</code> merkle-patricia-forestry ByteString ByteString"},{"location":"PHASE4-DESIGN/#combined-columns-gadt","title":"Combined Columns GADT","text":"<p>The GADT lives in mpfs-offchain since it is the application that owns the full schema. It extends cardano-utxo-csmt's columns with cage-specific and trie-specific ones:</p> <pre><code>data AllColumns x where\n    -- cardano-utxo-csmt columns\n    UTxOKV        :: AllColumns (KV LBS LBS)\n    UTxOCSMT      :: AllColumns (KV CSMTKey CSMTIndirect)\n    UTxORollbacks :: AllColumns (KV RollbackKey RollbackVal)\n    UTxOConfig    :: AllColumns (KV ConfigKey LBS)\n    -- cage state columns\n    CageTokens    :: AllColumns (KV TokenId TokenState)\n    CageRequests  :: AllColumns (KV TxIn Request)\n    CageCfg       :: AllColumns (KV () CageCheckpoint)\n    -- trie columns (per-token, prefixed)\n    TrieNodes     :: AllColumns (KV LBS LBS)\n    TrieKV        :: AllColumns (KV LBS LBS)\n</code></pre> <p>All column families are created when the RocksDB instance is opened. The <code>Database</code> record from <code>rocksdb-kv-transactions</code> provides a unified handle. Transactions compose operations on any subset of columns and commit atomically.</p>"},{"location":"PHASE4-DESIGN/#block-processing-pipeline","title":"Block processing pipeline","text":""},{"location":"PHASE4-DESIGN/#on-rollforward","title":"On rollForward","text":"<pre><code>rollForward :: Fetched -&gt; SlotNo -&gt; IO (Follower Fetched)\n  1. utxoOps   = uTxOs block          -- [Change]\n  2. cageOps   = detectCage block      -- [CageEvent]\n  3. runTransaction $ do\n       -- UTxO index (delegated to cardano-utxo-csmt)\n       applyUTxOOps slot utxoOps\n       -- Cage state\n       for_ cageOps $ \\case\n         CageBoot tokenId tokenState -&gt;\n           insert CageTokens tokenId tokenState\n         CageRequest txIn request -&gt;\n           insert CageRequests txIn request\n         CageUpdate tokenId newRoot removedReqs -&gt;\n           update CageTokens tokenId (setRoot newRoot)\n           for_ removedReqs (delete CageRequests)\n           applyTrieMutations tokenId ...\n         CageRetract txIn -&gt;\n           delete CageRequests txIn\n         CageBurn tokenId -&gt;\n           delete CageTokens tokenId\n       -- Checkpoint\n       insert CageCfg () (CageCheckpoint slot blockId)\n</code></pre>"},{"location":"PHASE4-DESIGN/#on-rollbackward","title":"On rollBackward","text":"<pre><code>rollBackward :: Point -&gt; IO (ProgressOrRewind Fetched)\n  1. Delegate to cardano-utxo-csmt's rollbackTipApply\n     (reverts UTxO index via inverse operations)\n  2. In the same transaction, revert cage state:\n     - Restore tokens/requests from inverse operations\n     - Restore trie state from checkpoint\n  3. Atomic commit\n</code></pre>"},{"location":"PHASE4-DESIGN/#cage-event-detection","title":"Cage event detection","text":"<p>A <code>CageEvent</code> is extracted by inspecting each transaction in the block for interactions with the cage script address and policy ID:</p> <pre><code>data CageEvent\n    = CageBoot TokenId TokenState\n      -- ^ Mint with cage policyId \u2192 new token\n    | CageRequest TxIn Request\n      -- ^ Output to cage address with RequestDatum\n    | CageUpdate TokenId Root [TxIn]\n      -- ^ Input from cage address with Modify redeemer\n    | CageRetract TxIn\n      -- ^ Input from cage address with Retract redeemer\n    | CageBurn TokenId\n      -- ^ Burn with cage policyId \u2192 token removed\n</code></pre> <p>Detection rules:</p> Event Signal Boot Tx mints exactly +1 token under <code>cagePolicyId</code>. Decode the <code>StateDatum</code> from the new cage output. Request Tx creates output at <code>cageAddr</code> with <code>RequestDatum</code> inline datum. No script input required. Update Tx consumes cage UTxO with <code>Modify</code> spending redeemer. Decode new <code>StateDatum</code> from continuing output. Consumed <code>RequestDatum</code> inputs are the processed requests. Retract Tx consumes cage UTxO with <code>Retract</code> spending redeemer. The consumed <code>RequestDatum</code> input is removed. Burn Tx mints -1 token under <code>cagePolicyId</code>. <p>The detection function needs access to: - The transaction's minted values (for boot/burn) - The transaction's outputs with inline datums (for request) - The transaction's inputs + redeemers (for update/retract) - The previous UTxO set (to resolve spent inputs)</p> <p>Since we process blocks sequentially and the UTxO index is updated in the same transaction, we can resolve spent inputs from the UTxO index before applying the current block's UTxO changes, or we can use cardano-utxo-csmt's <code>Query.getValue</code> within the transaction workspace.</p>"},{"location":"PHASE4-DESIGN/#trie-persistence","title":"Trie persistence","text":""},{"location":"PHASE4-DESIGN/#per-token-trie-isolation","title":"Per-token trie isolation","text":"<p>Each cage token has its own MPF trie. On chain, the trie root is stored in the <code>StateDatum</code>. Off chain, the trie nodes and key-value pairs are stored in RocksDB.</p> <p>Key prefix strategy: Trie column families are shared across all tokens. Keys are prefixed with the <code>TokenId</code> to isolate per-token data:</p> <pre><code>trie-nodes key = tokenId ++ originalKey\ntrie-kv key    = tokenId ++ originalKey\n</code></pre> <p>This avoids creating per-token column families (RocksDB column families are heavyweight, not meant to be dynamic).</p>"},{"location":"PHASE4-DESIGN/#trie-mutations-in-the-transaction","title":"Trie mutations in the transaction","text":"<p>When an <code>Update</code> cage event is detected, the block processor:</p> <ol> <li>Reads the consumed <code>RequestDatum</code> inputs to get the    operations (insert/delete key-value pairs)</li> <li>Applies each operation to the token's trie within the    same RocksDB transaction</li> <li>The resulting root hash must match the <code>stateRoot</code> in the    new <code>StateDatum</code> (this is enforced on-chain by the Aiken    validator, but we verify it off-chain as a sanity check)</li> </ol>"},{"location":"PHASE4-DESIGN/#triemanager-replacement","title":"TrieManager replacement","text":"<p>The current <code>TrieManager</code> interface uses in-memory <code>IORef MPFInMemoryDB</code>. The persistent version wraps the shared RocksDB transaction:</p> <pre><code>mkPersistentTrieManager\n    :: RunTransaction IO CF AllColumns BatchOp\n    -&gt; TrieManager IO\n</code></pre> <p>Operations (<code>insert</code>, <code>delete</code>, <code>lookup</code>, <code>getRoot</code>, <code>getProof</code>) are translated to prefixed reads/writes on the <code>TrieNodes</code> and <code>TrieKV</code> column families.</p>"},{"location":"PHASE4-DESIGN/#rollback-strategy","title":"Rollback strategy","text":""},{"location":"PHASE4-DESIGN/#the-problem","title":"The problem","text":"<p>Rollbacks must revert three domains atomically: 1. UTxO index (handled by cardano-utxo-csmt's inverse ops) 2. Cage state (tokens, requests) 3. Trie state (per-token Merkle tries)</p>"},{"location":"PHASE4-DESIGN/#the-solution-inverse-operations","title":"The solution: inverse operations","text":"<p>Following cardano-utxo-csmt's pattern, we record inverse operations for cage state changes at each block:</p> <pre><code>data CageInverseOp\n    = InvInsertToken TokenId TokenState\n      -- ^ To undo a delete: re-insert\n    | InvDeleteToken TokenId\n      -- ^ To undo an insert: delete\n    | InvInsertRequest TxIn Request\n      -- ^ To undo a delete: re-insert\n    | InvDeleteRequest TxIn\n      -- ^ To undo an insert: delete\n    | InvSetRoot TokenId Root\n      -- ^ To undo a root change: restore old root\n</code></pre> <p>These are stored alongside cardano-utxo-csmt's rollback points in the same <code>rollbacks</code> column family (or a parallel <code>cage-rollbacks</code> column family).</p> <p>On rollback to slot S: 1. Replay inverse operations from the rollback point 2. Restore trie state (see below)</p>"},{"location":"PHASE4-DESIGN/#trie-rollback","title":"Trie rollback","text":"<p>Trie mutations are harder to invert because the MPF trie is a Merkle structure \u2014 you can't just \"undo\" a hash. Two options:</p> <p>A) Store trie inverse ops \u2014 For each trie mutation, store the old key-value pair. On rollback, replay inverses. Since the trie is deterministic (same inputs \u2192 same root), replaying in reverse restores the correct state.</p> <p>B) Snapshot trie roots \u2014 Store periodic snapshots of the full trie. On rollback, restore from the nearest snapshot and replay forward. More expensive in storage but simpler.</p> <p>Choice: A \u2014 Store trie inverse operations. The trie is deterministic, so replaying inverses in order produces the correct root. This is consistent with how cardano-utxo-csmt handles UTxO rollbacks.</p>"},{"location":"PHASE4-DESIGN/#cardano-utxo-csmt-integration","title":"cardano-utxo-csmt integration","text":""},{"location":"PHASE4-DESIGN/#dependency-setup","title":"Dependency setup","text":"<p>Add <code>cardano-utxo-csmt</code> as a <code>source-repository-package</code> in <code>cabal.project</code>, along with its transitive dependencies:</p> <pre><code>source-repository-package\n  type: git\n  location: https://github.com/paolino/cardano-utxo-csmt\n  tag: &lt;commit-hash&gt;\n\nsource-repository-package\n  type: git\n  location: https://github.com/paolino/haskell-csmt\n  tag: &lt;commit-hash&gt;\n\nsource-repository-package\n  type: git\n  location: https://github.com/paolino/cardano-read-ledger\n  tag: &lt;commit-hash&gt;\n\nsource-repository-package\n  type: git\n  location: https://github.com/paolino/contra-tracer-contrib\n  tag: &lt;commit-hash&gt;\n</code></pre> <p>In <code>flake.nix</code>, no new inputs are needed \u2014 these are pure Haskell packages resolved by haskell.nix from the cabal project file.</p>"},{"location":"PHASE4-DESIGN/#what-we-import","title":"What we import","text":"<p>From <code>cardano-utxo-csmt</code> (library): - <code>Cardano.UTxOCSMT.Ouroboros.ConnectionN2C</code> \u2014 N2C socket connection - <code>Cardano.UTxOCSMT.Ouroboros.Types</code> \u2014 <code>Follower</code>, <code>Intersector</code>, <code>Block</code>, <code>Point</code>, <code>TipOf</code> - <code>Cardano.UTxOCSMT.Application.ChainSyncN2C</code> \u2014 ChainSync client - <code>Cardano.UTxOCSMT.Application.Database.Interface</code> \u2014 <code>Update</code>, <code>State</code>, <code>Query</code>, <code>Operation</code> - <code>Cardano.UTxOCSMT.Application.Database.RocksDB</code> \u2014 DB setup - <code>Cardano.UTxOCSMT.Application.UTxOs</code> \u2014 <code>uTxOs</code>, <code>Change</code></p>"},{"location":"PHASE4-DESIGN/#what-we-replace","title":"What we replace","text":"Before (Phase 3) After (Phase 4) <code>NodeClient.Connection</code> (custom N2C) <code>ConnectionN2C.runLocalNodeApplication</code> <code>NodeClient.LocalStateQuery</code> (LSQ for UTxOs) <code>Query.getValue</code> on UTxO column <code>Mock.State</code> (IORef maps) RocksDB columns via <code>RunTransaction</code> <code>Trie.PureManager</code> (IORef) RocksDB columns with token-prefixed keys <code>Mock.Skeleton</code> (no-op) Real <code>Follower</code> processing blocks"},{"location":"PHASE4-DESIGN/#what-we-keep","title":"What we keep","text":"<ul> <li><code>NodeClient.LocalTxSubmission</code> \u2014 still needed for tx   submission (cardano-utxo-csmt doesn't submit)</li> <li><code>NodeClient.LocalStateQuery</code> \u2014 still needed for   <code>queryProtocolParams</code> (epoch-cached)</li> <li><code>TxBuilder.Real.*</code> \u2014 transaction construction unchanged</li> <li><code>Balance</code> \u2014 fee estimation unchanged</li> </ul>"},{"location":"PHASE4-DESIGN/#connection-strategy","title":"Connection strategy","text":"<p>Two N2C connections to the same node socket:</p> <ol> <li>cardano-utxo-csmt connection \u2014 ChainSync only    (blocks arrive here, processed by our Follower)</li> <li>mpfs-offchain connection \u2014 LocalTxSubmission +    LocalStateQuery (tx submission + protocol params)</li> </ol> <p>Both connect to the same Unix socket. The node handles multiple client connections.</p>"},{"location":"PHASE4-DESIGN/#application-wiring-updated","title":"Application wiring (updated)","text":"<pre><code>withApplication :: AppConfig -&gt; (Context IO -&gt; IO a) -&gt; IO a\nwithApplication cfg action = do\n    -- 1. Open shared RocksDB with all column families\n    withSharedDB dbPath allColumnFamilies $ \\db -&gt; do\n        -- 2. Create RunTransaction (MVar-serialized)\n        runner &lt;- newRunTransaction db\n\n        -- 3. Initialize cardano-utxo-csmt state machine\n        (utxoUpdate, utxoQuery) &lt;- initUTxOCSMT runner\n\n        -- 4. Create persistent cage state interface\n        let cageState = mkPersistentState runner\n\n        -- 5. Create persistent trie manager\n        let trieManager = mkPersistentTrieManager runner\n\n        -- 6. Build the Follower (block processor)\n        let follower = mkCageFollower runner utxoUpdate\n                cageState trieManager cagePolicyId\n\n        -- 7. Start ChainSync N2C (blocks \u2192 follower)\n        async $ runLocalNodeApplication magic socket\n            (mkN2CChainSyncApplication ... follower ...)\n\n        -- 8. Start LSQ + TxSubmission N2C connection\n        (lsqChan, ltxsChan) &lt;- startN2CConnection magic socket\n\n        -- 9. Wire Provider (UTxO from RocksDB, params from LSQ)\n        let provider = Provider\n                { queryUTxOs = queryByAddress utxoQuery\n                , queryProtocolParams = queryLSQ lsqChan ...\n                , evaluateTx = ...\n                }\n\n        -- 10. Wire remaining components\n        let submitter = mkN2CSubmitter ltxsChan\n            txBuilder = mkRealTxBuilder cageConfig provider\n                cageState trieManager\n            context = Context { provider, trieManager,\n                state = cageState, indexer, submitter,\n                txBuilder }\n\n        action context\n</code></pre>"},{"location":"PHASE4-DESIGN/#invariants-to-be-formalized-in-lean-4","title":"Invariants (to be formalized in Lean 4)","text":""},{"location":"PHASE4-DESIGN/#inv-1-atomic-block-processing","title":"INV-1: Atomic block processing","text":"<p>For any block B at slot S, the state transition from <code>state(S-1)</code> to <code>state(S)</code> is atomic. Either all of these hold simultaneously or none: - UTxO set reflects all spends and creates in B - Cage tokens reflect all boot/burn events in B - Cage requests reflect all request/retract/update events in B - Trie roots match the on-chain StateDatum roots after   processing all updates in B</p>"},{"location":"PHASE4-DESIGN/#inv-2-rollback-correctness","title":"INV-2: Rollback correctness","text":"<p>For any rollback to slot S, the resulting state is identical to the state that existed at slot S. Formally:</p> <pre><code>rollback(process(state(S), blocks(S+1..S+n)), S) = state(S)\n</code></pre> <p>This must hold for UTxO index, cage state, and trie state.</p>"},{"location":"PHASE4-DESIGN/#inv-3-cage-event-completeness","title":"INV-3: Cage event completeness","text":"<p>For any block B, the set of detected <code>CageEvent</code>s is exactly the set of cage-relevant transactions in B. No cage transaction is missed, no non-cage transaction is misidentified.</p>"},{"location":"PHASE4-DESIGN/#inv-4-trie-state-consistency","title":"INV-4: Trie-state consistency","text":"<p>After processing any block, for every token T with <code>TokenState.root = R</code>, the actual Merkle root of T's persisted trie equals R.</p>"},{"location":"PHASE4-DESIGN/#inv-5-inverse-operation-correctness","title":"INV-5: Inverse operation correctness","text":"<p>For any forward operation <code>op</code> producing inverse <code>inv(op)</code>, applying <code>inv(op)</code> after <code>op</code> restores the original state:</p> <pre><code>apply(inv(op), apply(op, state)) = state\n</code></pre>"},{"location":"PHASE4-DESIGN/#design-decisions-resolved","title":"Design decisions (resolved)","text":"<ol> <li> <p>Protocol params source \u2014 Keep LSQ. Params change at    most once per epoch and are only queried when building    transactions, not per-block.</p> </li> <li> <p>Provider.queryUTxOs source \u2014 Use cardano-utxo-csmt's    local UTxO index (<code>Query.getByAddress</code>). LSQ-based    <code>queryUTxOs</code> is unusable. The <code>Provider</code> gains a    dependency on cardano-utxo-csmt's query interface. The    N2C LSQ connection is only needed for protocol params    and tx evaluation.</p> </li> <li> <p>Trie prefix efficiency \u2014 Deferred. Prefixed keys in    shared column families work correctly. RocksDB prefix    bloom filter configuration is a future optimization    (see #40).</p> </li> <li> <p>Transaction serialization \u2014 Keep the MVar. Atomicity    is required. Block processing is well within the block    interval on both mainnet (20s) and devnet (0.1s).</p> </li> </ol>"},{"location":"architecture/data-sources/","title":"Data Sources","text":"<p>All external data enters the system through a single Cardano node connection. There is no Ogmios, no Yaci Store \u2014 only a node-to-client (N2C) Unix socket carrying multiplexed mini-protocols.</p>"},{"location":"architecture/data-sources/#connection","title":"Connection","text":"<pre><code>graph LR\n    NODE[\"Cardano Node&lt;br/&gt;(Unix socket)\"]\n\n    LSQ[\"LocalStateQuery&lt;br/&gt;(mini-protocol 7)\"]\n    LTS[\"LocalTxSubmission&lt;br/&gt;(mini-protocol 6)\"]\n\n    NODE --- LSQ\n    NODE --- LTS\n\n    PRV[\"Provider\"]\n    SUB[\"Submitter\"]\n\n    LSQ --&gt; PRV\n    LTS --&gt; SUB</code></pre> <p>Both mini-protocols share the same multiplexed socket via <code>ouroboros-network</code>. The connection is established by <code>runNodeClient</code> and runs in a background thread.</p>"},{"location":"architecture/data-sources/#data-flow","title":"Data Flow","text":"<pre><code>graph TD\n    subgraph \"Cardano Node\"\n        LSQ[\"LocalStateQuery\"]\n        LTS[\"LocalTxSubmission\"]\n    end\n\n    subgraph \"Singletons\"\n        PRV[\"Provider\"]\n        SUB[\"Submitter\"]\n    end\n\n    LSQ --&gt;|\"protocol params\"| PRV\n    LSQ --&gt;|\"UTxOs by address\"| PRV\n    LTS --&gt; SUB</code></pre>"},{"location":"architecture/data-sources/#n2c-mini-protocols","title":"N2C Mini-Protocols","text":""},{"location":"architecture/data-sources/#localstatequery-protocol-7","title":"LocalStateQuery (protocol 7)","text":"<p>Queries the current ledger state. Used for two purposes:</p> <ol> <li> <p>Protocol parameters \u2014 fee coefficients, max transaction size,    minimum UTxO value, collateral percentage, Plutus execution prices.    Queried via <code>GetCurrentPParams</code> (Conway era).</p> </li> <li> <p>UTxO queries \u2014 look up UTxOs at a given address via    <code>GetUTxOByAddress</code>. Used for coin selection and locating    script inputs.</p> </li> </ol> <p>The Provider acquires the tip on each query \u2014 no long-lived acquired state.</p>"},{"location":"architecture/data-sources/#localtxsubmission-protocol-6","title":"LocalTxSubmission (protocol 6)","text":"<p>Submits a signed <code>Tx ConwayEra</code> to the node's mempool. The Submitter converts the ledger transaction to a consensus <code>GenTx</code> and returns either <code>Submitted txId</code> or <code>Rejected reason</code>.</p>"},{"location":"architecture/data-sources/#channel-architecture","title":"Channel Architecture","text":"<p>Communication between the N2C connection thread and the Provider / Submitter uses <code>TBQueue</code>-backed channels:</p> <ul> <li><code>LSQChannel</code> \u2014 carries <code>(query, resultVar)</code> pairs. The   Provider writes a query and blocks on the result MVar.</li> <li><code>LTxSChannel</code> \u2014 carries <code>(genTx, resultVar)</code> pairs. The   Submitter writes a transaction and blocks on the result MVar.</li> </ul> <p>The N2C client thread reads from these queues and drives the protocol state machines.</p>"},{"location":"architecture/data-sources/#future-chainsync","title":"Future: ChainSync","text":"<p>ChainSync (mini-protocol 5) is not yet wired. When implemented, it will feed blocks to the Indexer for processing token events, request tracking, and trie updates. The current skeleton indexer returns a genesis tip placeholder.</p>"},{"location":"architecture/overview/","title":"Architecture Overview","text":""},{"location":"architecture/overview/#system-stack","title":"System Stack","text":"<pre><code>flowchart TD\n    app[\"Application&lt;br/&gt;(wiring + lifecycle)\"]\n    mpf[\"MPF Trie&lt;br/&gt;(merkle-patricia-forestry)&lt;br/&gt;Proofs, insertion, deletion\"]\n    txb[\"TxBuilder&lt;br/&gt;(MPFS protocol operations)&lt;br/&gt;boot, update, retract, end\"]\n    bal[\"Balance&lt;br/&gt;(fee estimation fixpoint)\"]\n    n2c[\"Node Client&lt;br/&gt;(node-to-client)&lt;br/&gt;LocalStateQuery + LocalTxSubmission\"]\n\n    app --&gt; mpf --&gt; txb --&gt; bal --&gt; n2c</code></pre> <p>The service connects to a Cardano node via a Unix socket carrying multiplexed N2C mini-protocols. The <code>Provider</code> queries UTxOs and protocol parameters via <code>LocalStateQuery</code>; the <code>Submitter</code> sends signed transactions via <code>LocalTxSubmission</code>. The <code>TxBuilder</code> constructs MPFS protocol transactions (boot, update, retract, end) and <code>balanceTx</code> handles fee estimation through a fixpoint loop.</p>"},{"location":"architecture/overview/#singleton-dependency-graph","title":"Singleton Dependency Graph","text":"<p>Every major component is a record of functions (no typeclasses). Records are created bottom-up and torn down top-down using bracket patterns.</p> <pre><code>graph TD\n    APP[\"Application&lt;br/&gt;(withApplication)\"]\n    CTX[\"Context&lt;br/&gt;(facade record)\"]\n    PRV[\"Provider&lt;br/&gt;(N2C LocalStateQuery)\"]\n    TM[\"TrieManager&lt;br/&gt;(per-token MPF tries)\"]\n    ST[\"State&lt;br/&gt;(tokens, requests, checkpoints)\"]\n    IDX[\"Indexer&lt;br/&gt;(skeleton / chain sync)\"]\n    SUB[\"Submitter&lt;br/&gt;(N2C LocalTxSubmission)\"]\n    TXB[\"TxBuilder&lt;br/&gt;(MPFS protocol ops)\"]\n    NODE[\"Cardano Node&lt;br/&gt;(Unix socket)\"]\n\n    APP --&gt; CTX\n    CTX --&gt; PRV\n    CTX --&gt; TM\n    CTX --&gt; ST\n    CTX --&gt; IDX\n    CTX --&gt; SUB\n    CTX --&gt; TXB\n    PRV --&gt; NODE\n    SUB --&gt; NODE</code></pre>"},{"location":"architecture/overview/#application-wiring","title":"Application Wiring","text":"<p><code>withApplication</code> creates and wires all components:</p> <pre><code>graph LR\n    N2C[\"N2C Connection\"] --&gt; PRV[\"Provider\"]\n    N2C --&gt; SUB[\"Submitter\"]\n    MOCK_ST[\"Mock State\"] --&gt; ST[\"State\"]\n    PURE_TM[\"Pure TrieManager\"] --&gt; TM[\"TrieManager\"]\n    SKEL[\"Skeleton Indexer\"] --&gt; IDX[\"Indexer\"]\n    MOCK_TXB[\"Mock TxBuilder\"] --&gt; TXB[\"TxBuilder\"]\n    PRV &amp; SUB &amp; ST &amp; TM &amp; IDX &amp; TXB --&gt; CTX[\"Context\"]</code></pre> <p>The <code>Provider</code> and <code>Submitter</code> use real N2C connections. State, TrieManager, and Indexer currently use mock/pure/skeleton implementations.</p>"},{"location":"architecture/overview/#external-dependencies","title":"External Dependencies","text":"<pre><code>graph TD\n    OFFCHAIN[\"cardano-mpfs-offchain&lt;br/&gt;Service interfaces + N2C client\"]\n    MPF[\"merkle-patricia-forestry&lt;br/&gt;MPF trie library\"]\n    ONCHAIN[\"cardano-mpfs-onchain&lt;br/&gt;Aiken validators\"]\n    LEDGER[\"cardano-ledger&lt;br/&gt;Conway era types\"]\n    OUROBOROS[\"ouroboros-network&lt;br/&gt;N2C protocols\"]\n    PLUTUS[\"plutus-core / plutus-tx&lt;br/&gt;PlutusData encoding\"]\n\n    OFFCHAIN --&gt; MPF\n    OFFCHAIN --&gt; LEDGER\n    OFFCHAIN --&gt; OUROBOROS\n    OFFCHAIN --&gt; PLUTUS\n    OFFCHAIN -.-&gt;|\"on-chain types&lt;br/&gt;&amp; script hash\"| ONCHAIN\n\n    style OFFCHAIN fill:#e1f5fe\n    style MPF fill:#e8f5e9\n    style ONCHAIN fill:#fff3e0\n    style LEDGER fill:#f3e5f5\n    style OUROBOROS fill:#f3e5f5\n    style PLUTUS fill:#f3e5f5</code></pre> Color Meaning Blue This project Green MPF trie library (same repo) Orange On-chain Aiken validators (separate repo) Purple Cardano ecosystem dependencies"},{"location":"architecture/overview/#module-hierarchy","title":"Module Hierarchy","text":"<p>The <code>cardano-mpfs-offchain</code> library is organized in layers. All modules live under <code>Cardano.MPFS</code>.</p>"},{"location":"architecture/overview/#core-domain-types-and-pure-logic","title":"Core \u2014 domain types and pure logic","text":"Module Purpose <code>Core.Types</code> <code>TokenId</code>, <code>Root</code>, <code>Request</code>, <code>TokenState</code>, <code>CageConfig</code> <code>Core.OnChain</code> Datum/redeemer encodings, <code>cagePolicyId</code>, <code>cageAddress</code>, PlutusV3 script <code>Core.Blueprint</code> CIP-57 blueprint schema loading and validation <code>Core.Proof</code> MPF proof to on-chain <code>ProofStep</code> conversion <code>Core.Balance</code> <code>balanceTx</code> \u2014 fee estimation fixpoint loop <code>Core.Bootstrap</code> CBOR bootstrap file for UTxO seeding"},{"location":"architecture/overview/#interfaces-record-of-functions-singletons","title":"Interfaces \u2014 record-of-functions singletons","text":"Module Purpose <code>Context</code> Facade bundling all singletons <code>Provider</code> <code>queryUTxOs</code>, <code>queryProtocolParams</code> <code>State</code> <code>Tokens</code>, <code>Requests</code>, <code>Checkpoints</code> sub-records <code>Trie</code> <code>TrieManager</code> \u2014 per-token MPF trie access <code>TxBuilder</code> Cage protocol operations (boot, request, update, retract, end) <code>Indexer</code> Chain follower lifecycle (<code>start</code>, <code>stop</code>, <code>getTip</code>) <code>Submitter</code> <code>submitTx :: Tx ConwayEra -&gt; m SubmitResult</code> <code>Application</code> <code>withApplication</code> \u2014 wiring and lifecycle"},{"location":"architecture/overview/#indexer-chain-sync-and-persistence","title":"Indexer \u2014 chain sync and persistence","text":"Module Purpose <code>Indexer.Event</code> <code>detectCageEvents</code> \u2014 cage tx classification <code>Indexer.Follower</code> Block processor: events, trie mutations, inverse ops <code>Indexer.Persistent</code> RocksDB-backed <code>State</code> <code>Indexer.Columns</code> <code>AllColumns</code> GADT \u2014 full DB schema <code>Indexer.Codecs</code> CBOR serialization for column key-value types <code>Indexer.Rollback</code> <code>CageInverseOp</code> \u2014 undo operations"},{"location":"architecture/overview/#nodeclient-n2c-protocol-clients","title":"NodeClient \u2014 N2C protocol clients","text":"Module Purpose <code>NodeClient.Connection</code> <code>runNodeClient</code> \u2014 multiplexed N2C connection <code>NodeClient.LocalStateQuery</code> LSQ protocol client for UTxOs and PParams <code>NodeClient.LocalTxSubmission</code> Tx submission protocol client <code>NodeClient.Codecs</code> N2C codec bundle <code>NodeClient.Types</code> <code>LSQChannel</code>, <code>LTxSChannel</code>"},{"location":"architecture/overview/#txbuilder-cage-protocol-transactions","title":"TxBuilder \u2014 cage protocol transactions","text":"Module Purpose <code>TxBuilder.Config</code> <code>CageConfig</code> loading <code>TxBuilder.Real</code> <code>mkRealTxBuilder</code> entry point <code>TxBuilder.Real.Boot</code> Mint cage token <code>TxBuilder.Real.Request</code> Submit insert/delete request <code>TxBuilder.Real.Update</code> Consume requests, update root <code>TxBuilder.Real.Retract</code> Cancel pending request <code>TxBuilder.Real.End</code> Burn cage token <code>TxBuilder.Real.Internal</code> Shared helpers, POSIX-to-slot conversion"},{"location":"architecture/overview/#trie-mpf-backends","title":"Trie \u2014 MPF backends","text":"Module Purpose <code>Trie.Pure</code> <code>IORef</code>-backed in-memory trie <code>Trie.PureManager</code> <code>mkPureTrieManager</code> \u2014 in-memory <code>TrieManager</code> <code>Trie.Persistent</code> <code>mkPersistentTrieManager</code> \u2014 RocksDB with token-prefixed keys"},{"location":"architecture/overview/#mock-test-doubles","title":"Mock \u2014 test doubles","text":"Module Purpose <code>Mock.Context</code> <code>withMockContext</code> \u2014 full mock wiring <code>Mock.Provider</code> In-memory UTxO store <code>Mock.State</code> <code>mkMockState</code> \u2014 <code>IORef</code>-backed state <code>Mock.Submitter</code> Always-succeeds submitter <code>Mock.TxBuilder</code> <code>mkMockTxBuilder</code> \u2014 placeholder builder <code>Mock.Indexer</code> No-op indexer <code>Mock.Skeleton</code> <code>mkSkeletonIndexer</code> \u2014 lifecycle-only skeleton"},{"location":"architecture/overview/#design-principles","title":"Design Principles","text":"<ul> <li>No typeclasses \u2014 closed world with explicit records of functions.</li> <li>All types from cardano-ledger \u2014 <code>Tx ConwayEra</code>, <code>PParams ConwayEra</code>, <code>Addr</code>, <code>TxIn</code>, etc.</li> <li>Visible dependency graph \u2014 no implicit resolution surprises.</li> <li>Trivial testing \u2014 swap the record for a mock backend.</li> <li>No orphan instances.</li> </ul>"},{"location":"architecture/overview/#implementation-phases","title":"Implementation Phases","text":"<pre><code>graph LR\n    P0[\"Phase 0&lt;br/&gt;MPF Library \u2713\"]\n    P1[\"Phase 1&lt;br/&gt;Service Interfaces \u2713\"]\n    P2[\"Phase 2&lt;br/&gt;N2C Client +&lt;br/&gt;Provider \u2713\"]\n    P3[\"Phase 3&lt;br/&gt;Transaction&lt;br/&gt;Builders\"]\n    P4[\"Phase 4&lt;br/&gt;ChainSync Indexer +&lt;br/&gt;Persistent State\"]\n    P5[\"Phase 5&lt;br/&gt;HTTP API +&lt;br/&gt;Deployment\"]\n\n    P0 --&gt; P1 --&gt; P2 --&gt; P3 --&gt; P4 --&gt; P5\n\n    style P0 fill:#2d6,color:#fff\n    style P1 fill:#2d6,color:#fff\n    style P2 fill:#2d6,color:#fff\n    style P3 fill:#2d6,color:#fff\n    style P4 fill:#2d6,color:#fff</code></pre> Phase Description Status 0 MPF library \u2014 16-ary Merkle Patricia Forestry, Blake2b-256 hashing, insertion/deletion/proofs, pure and RocksDB backends Done 1 Service interfaces \u2014 <code>Provider</code>, <code>Submitter</code>, <code>TxBuilder</code>, <code>State</code>, <code>Indexer</code>, <code>TrieManager</code>, <code>Context</code> records; mock implementations; <code>balanceTx</code> with fixpoint fee estimation; on-chain type encodings; CIP-57 blueprint validation; Aiken-compatible proof serialization Done 2 N2C client + Provider \u2014 <code>ouroboros-network</code> LocalStateQuery and LocalTxSubmission clients; <code>mkNodeClientProvider</code> for UTxO and PParams queries; <code>mkN2CSubmitter</code> for transaction submission; E2E tests with cardano-node subprocess Done 3 Transaction builders \u2014 real <code>TxBuilder</code> implementations for boot, update, retract, end operations with Plutus script witnesses, proof embedding, and on-chain datum construction Done 4 ChainSync indexer + persistent state \u2014 replace skeleton indexer with real ChainSync follower; RocksDB-backed State and TrieManager; block processing with rollback support Done 5 HTTP API + deployment \u2014 Servant HTTP layer, Docker via Nix, deploy to plutimus.com Planned"},{"location":"architecture/singletons/","title":"Singletons","text":"<p>Every major component is a record of functions, polymorphic in the monad <code>m</code>. No typeclasses are used \u2014 dependencies are explicit and passed as values. This makes testing trivial: swap a record for a mock.</p>"},{"location":"architecture/singletons/#provider","title":"Provider","text":"<p>Blockchain queries (read-only). Queries a Cardano node via N2C LocalStateQuery.</p> <p>Implementation: <code>mkNodeClientProvider</code> (real N2C, in <code>Provider.NodeClient</code>)</p> <pre><code>data Provider m = Provider\n    { queryUTxOs\n        :: Addr\n        -&gt; m [(TxIn, TxOut ConwayEra)]\n    -- ^ Look up UTxOs at an address\n    , queryProtocolParams\n        :: m (PParams ConwayEra)\n    -- ^ Fetch current protocol parameters\n    , evaluateTx\n        :: ByteString -&gt; m ExUnits\n    -- ^ Evaluate execution units for a serialised\n    -- CBOR transaction (not yet implemented)\n    }\n</code></pre> <pre><code>graph LR\n    PRV[\"Provider\"]\n    NODE[\"Cardano Node&lt;br/&gt;(LocalStateQuery)\"]\n\n    PRV --&gt;|queryUTxOs| NODE\n    PRV --&gt;|queryProtocolParams| NODE</code></pre>"},{"location":"architecture/singletons/#triemanager","title":"TrieManager","text":"<p>Manages a map of token identifiers to MPF tries. Each token has its own isolated trie.</p> <p>Implementation: <code>mkPureTrieManager</code> (in-memory, in <code>Trie.PureManager</code>) Persistent: <code>mkPersistentTrieManager</code> (RocksDB, in <code>Trie.Persistent</code>)</p> <pre><code>data TrieManager m = TrieManager\n    { withTrie\n        :: forall a\n         . TokenId\n        -&gt; (Trie m -&gt; m a)\n        -&gt; m a\n    -- ^ Run an action with access to a token's trie\n    , createTrie :: TokenId -&gt; m ()\n    -- ^ Create a new empty trie for a token\n    , deleteTrie :: TokenId -&gt; m ()\n    -- ^ Delete a token's trie\n    }\n\ndata Trie m = Trie\n    { insert\n        :: ByteString -&gt; ByteString -&gt; m Root\n    , delete :: ByteString -&gt; m Root\n    , lookup :: ByteString -&gt; m (Maybe ByteString)\n    , getRoot :: m Root\n    , getProof :: ByteString -&gt; m (Maybe Proof)\n    }\n</code></pre>"},{"location":"architecture/singletons/#state","title":"State","text":"<p>Token and request state tracking. Three sub-records for tokens, requests, and chain sync checkpoints.</p> <p>Implementation: <code>mkMockState</code> (in-memory, in <code>Mock.State</code>) Persistent: <code>Indexer.Persistent</code> (RocksDB)</p> <pre><code>data State m = State\n    { tokens :: Tokens m\n    , requests :: Requests m\n    , checkpoints :: Checkpoints m\n    }\n\ndata Tokens m = Tokens\n    { getToken :: TokenId -&gt; m (Maybe TokenState)\n    , putToken :: TokenId -&gt; TokenState -&gt; m ()\n    , removeToken :: TokenId -&gt; m ()\n    , listTokens :: m [TokenId]\n    }\n\ndata Requests m = Requests\n    { getRequest :: TxIn -&gt; m (Maybe Request)\n    , putRequest :: TxIn -&gt; Request -&gt; m ()\n    , removeRequest :: TxIn -&gt; m ()\n    , requestsByToken :: TokenId -&gt; m [Request]\n    }\n\ndata Checkpoints m = Checkpoints\n    { getCheckpoint :: m (Maybe (SlotNo, BlockId))\n    , putCheckpoint :: SlotNo -&gt; BlockId -&gt; m ()\n    }\n</code></pre>"},{"location":"architecture/singletons/#indexer","title":"Indexer","text":"<p>Chain sync follower with lifecycle control. Currently a skeleton that returns a genesis tip.</p> <p>Mock: <code>mkSkeletonIndexer</code> (no-op, in <code>Mock.Skeleton</code>) Real: <code>Indexer.Follower</code> (block processing with <code>detectCageEvents</code>)</p> <pre><code>data ChainTip = ChainTip\n    { tipSlot :: SlotNo\n    , tipBlockId :: BlockId\n    }\n\ndata Indexer m = Indexer\n    { start :: m ()\n    , stop :: m ()\n    , pause :: m ()\n    , resume :: m ()\n    , getTip :: m ChainTip\n    }\n</code></pre>"},{"location":"architecture/singletons/#submitter","title":"Submitter","text":"<p>Transaction submission via N2C LocalTxSubmission. Takes a full ledger <code>Tx ConwayEra</code> and returns a <code>SubmitResult</code>.</p> <p>Implementation: <code>mkN2CSubmitter</code> (real N2C, in <code>Submitter.N2C</code>)</p> <pre><code>data SubmitResult\n    = Submitted TxId\n    | Rejected ByteString\n\nnewtype Submitter m = Submitter\n    { submitTx :: Tx ConwayEra -&gt; m SubmitResult\n    }\n</code></pre>"},{"location":"architecture/singletons/#txbuilder","title":"TxBuilder","text":"<p>Constructs transactions for all MPFS protocol operations. Returns full ledger <code>Tx</code> values ready for signing.</p> <p>Mock: <code>mkMockTxBuilder</code> (in <code>Mock.TxBuilder</code>) Real: <code>mkRealTxBuilder</code> (in <code>TxBuilder.Real</code>)</p> <pre><code>data TxBuilder m = TxBuilder\n    { bootToken\n        :: Addr -&gt; m (Tx ConwayEra)\n    -- ^ Create a new MPFS token\n    , requestInsert\n        :: TokenId -&gt; ByteString -&gt; ByteString\n        -&gt; Addr -&gt; m (Tx ConwayEra)\n    -- ^ Request inserting a key-value pair\n    , requestDelete\n        :: TokenId -&gt; ByteString\n        -&gt; Addr -&gt; m (Tx ConwayEra)\n    -- ^ Request deleting a key\n    , updateToken\n        :: TokenId -&gt; Addr -&gt; m (Tx ConwayEra)\n    -- ^ Process pending requests for a token\n    , retractRequest\n        :: TxIn -&gt; Addr -&gt; m (Tx ConwayEra)\n    -- ^ Cancel a pending request\n    , endToken\n        :: TokenId -&gt; Addr -&gt; m (Tx ConwayEra)\n    -- ^ Retire an MPFS token\n    }\n</code></pre>"},{"location":"architecture/singletons/#balance","title":"Balance","text":"<p>Pure transaction balancing function (not a singleton record), in <code>Core.Balance</code>. Adds a fee-paying UTxO and change output, finding the fee via a fixpoint loop over <code>estimateMinFeeTx</code>.</p> <pre><code>balanceTx\n    :: PParams ConwayEra\n    -&gt; (TxIn, TxOut ConwayEra)   -- fee-paying UTxO\n    -&gt; Addr                       -- change address\n    -&gt; Tx ConwayEra               -- unbalanced tx\n    -&gt; Either BalanceError (Tx ConwayEra)\n</code></pre> <p>The fee estimation iterates until stable (max 10 rounds, crashes if not converged). One key witness is assumed for the fee input.</p>"},{"location":"architecture/singletons/#context","title":"Context","text":"<p>Facade record that bundles all singletons into a single environment.</p> <pre><code>data Context m = Context\n    { provider :: Provider m\n    , trieManager :: TrieManager m\n    , state :: State m\n    , indexer :: Indexer m\n    , submitter :: Submitter m\n    , txBuilder :: TxBuilder m\n    }\n</code></pre> <pre><code>graph TD\n    CTX[\"Context\"]\n    PRV[\"Provider\"]\n    TM[\"TrieManager\"]\n    ST[\"State\"]\n    IDX[\"Indexer\"]\n    SUB[\"Submitter\"]\n    TXB[\"TxBuilder\"]\n\n    CTX --&gt; PRV\n    CTX --&gt; TM\n    CTX --&gt; ST\n    CTX --&gt; IDX\n    CTX --&gt; SUB\n    CTX --&gt; TXB</code></pre>"},{"location":"architecture/testing/","title":"Testing","text":""},{"location":"architecture/testing/#unit-tests","title":"Unit Tests","text":"<p>Two unit test suites:</p> <ul> <li><code>merkle-patricia-forestry:unit-tests</code> \u2014 MPF trie operations,   hashing, proofs, insertion/deletion round-trips</li> <li><code>cardano-mpfs-offchain:unit-tests</code> \u2014 balance, on-chain type   encoding, proof serialization, trie manager, state tracking</li> </ul> <pre><code>just unit            # MPF unit tests\njust unit-offchain   # offchain unit tests\n</code></pre> <p>Unit tests use mock implementations (<code>mkMockState</code>, <code>mkPureTrieManager</code>, <code>mkMockTxBuilder</code>) and don't require a running Cardano node.</p>"},{"location":"architecture/testing/#e2e-tests","title":"E2E Tests","text":"<p>End-to-end tests run against a real <code>cardano-node</code> subprocess. No Docker, no external services.</p> <pre><code>just e2e             # E2E tests (requires cardano-node in PATH)\n</code></pre>"},{"location":"architecture/testing/#how-it-works","title":"How It Works","text":"<p>The test harness (<code>Cardano.MPFS.E2E.Devnet</code>) manages a single-node devnet:</p> <ol> <li> <p>Genesis files are checked into <code>e2e-test/genesis/</code>. They    define a testnet with magic 42, 0.1s slots, all hard forks at    epoch 0 (instant Conway).</p> </li> <li> <p>At startup, the harness copies genesis files to a temp    directory and patches <code>systemStart</code> to current UTC time + 5    seconds (giving the node time to initialize before the first    slot).</p> </li> <li> <p><code>cardano-node run</code> starts as a subprocess with delegate keys    for block production. The harness polls for the socket file    (up to 30 seconds).</p> </li> <li> <p>Tests use genesis UTxO funds directly \u2014 a deterministic    signing key derived from a hardcoded seed matches the    <code>initialFunds</code> address in <code>shelley-genesis.json</code>. No faucet    or top-up mechanism needed.</p> </li> <li> <p>After tests complete, the node is terminated and the temp    directory cleaned. No root-owned files.</p> </li> </ol>"},{"location":"architecture/testing/#test-specs","title":"Test Specs","text":"<ul> <li>ProviderSpec \u2014 queries protocol parameters and UTxOs via the   real N2C <code>LocalStateQuery</code> protocol</li> <li>SubmitterSpec \u2014 builds a simple ADA transfer, balances it   with <code>balanceTx</code>, signs with the genesis key, and submits via   the real N2C <code>LocalTxSubmission</code> protocol</li> </ul>"},{"location":"architecture/testing/#prerequisites","title":"Prerequisites","text":"<p><code>cardano-node</code> and <code>cardano-cli</code> must be in <code>PATH</code>. The nix dev shell provides them:</p> <pre><code>nix develop    # adds cardano-node 10.5.4 to PATH\njust e2e\n</code></pre>"},{"location":"architecture/testing/#genesis-configuration","title":"Genesis Configuration","text":"Parameter Value Why <code>testnetMagic</code> 42 Arbitrary devnet identifier <code>slotLength</code> 0.1s Fast block production for tests <code>activeSlotsCoeff</code> 1.0 Every slot produces a block <code>epochLength</code> 500 Short epochs <code>securityParam</code> 10 1-second stability window (10 \u00d7 0.1s) <code>systemStart</code> patched at runtime UTC now + 5 seconds All hard forks epoch 0 Instant Conway"}]}